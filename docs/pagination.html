<!DOCTYPE html><html lang="en">
<head><title>Pagination - Roman Zolotarev</title><meta charset="utf-8"><meta name="referrer" content="no-referrer"><link rel="stylesheet" href="/styles.css"><link rel="manifest" href="/manifest.webmanifest"><meta name="theme-color" content="#ffffff"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
</head>
<body><script>!function(t){ t.addEventListener('DOMContentLoaded', function () { var l = t.querySelector('#light-off'); if (l === null) { console.log('Lights-out...'); } else { l.checked = t.cookie.match(/lightOff=true/) !== null; l.addEventListener('change', function () { t.cookie = 'lightOff=' + JSON.stringify(l.checked) + ';path=/'; }); } })}(document);</script><input class="light-off" type="checkbox" id="light-off">
<div class="page">
<div class="header"><div class="header__home"><a href="/">Home</a> - <a href="https://twitter.com/romanzolotarev">Twitter</a></div><div class="header__light-off"><label for="light-off" class="light-off-button"></label></div></div>
<div class="article"><h1 id="Pagination">Pagination</h1>

<p>I recently worked on pagination for a web app. This simple problem is a
good case study for comparing JavaScript and Elm.</p>

<p>Here&#8217;s the use case:</p>

<p>We have a current page address, for example <strong>index</strong>, and a list of all
the page addresses: <strong>index</strong>, <strong>vanilla</strong>, <strong>ramda</strong>, <strong>elm</strong>.</p>

<p>There are two links, <strong>Previous</strong> and <strong>Next</strong>. By clicking on those links
you go to the previous or the next page accordingly.</p>

<p>When you&#8217;re on the first page, the <strong>Previous</strong> link is disabled. When
you&#8217;re on the last page, <strong>Next</strong> is disabled.</p>

<pre><code>              current page
                  |
                  |
[ Previous ]    index    vanilla    ramda    elm    [ Next ]
      |
      |
disabled link
</code></pre>

<p>Let&#8217;s write two functions &#8212; one to prepare a data structure and another
to generate HTML code based on it.</p>

<h2 id="The%20%3Ccode%3Epaginate()%3C/code%3E%20function">The <code>paginate()</code> function</h2>

<p>This function takes a <strong>current</strong> page and a list of <strong>pages</strong>. It returns
a tuple of <strong>previous</strong>, <strong>next</strong>. Both elements of the tuple can be
empty.</p>

<h2 id="The%20%3Ccode%3Ehtml()%3C/code%3E%20function">The <code>html()</code> function</h2>

<p>This function takes the result of <code>paginate()</code> and returns an HTML string
containing links to the next and previous pages. It handles cases when a
current page is not found, or either of the <strong>previous</strong> or <strong>next</strong> links
is missing.</p>

<pre><code>// List of pages
pages = [&#39;index&#39;, &#39;vanilla&#39;, &#39;ramda&#39;, &#39;elm&#39;]

// There should be no Previous page
paginate(&#39;index&#39;, pages);
// =&gt; [undefined, &#39;vanilla&#39;]

html(paginate(&#39;index&#39;, pages));
// =&gt; &#39;No previous&lt;a href=&quot;vanilla&quot;&gt;Next&lt;/a&gt;&#39;

// Both links are available
html(paginate(&#39;vanilla&#39;, pages));
// =&gt; &#39;&lt;a href=&quot;index&quot;&gt;Previous&lt;/a&gt;&lt;a href=&quot;ramda&quot;&gt;Next&lt;/a&gt;&#39;

// Non-existent page
html(paginate(&#39;pageX&#39;, pages));
// =&gt; &#39;Current not found&#39;
</code></pre>

<p>To start with, let&#8217;s implement this in vanilla JavaScript.</p>

<h2 id="Vanilla%20JavaScript">Vanilla JavaScript</h2>

<p>We&#8217;ll start with a plain JavaScript implementation; to be specific,
ECMAScript 5. Then we&#8217;ll see what we can improve.</p>

<p>How can we implement <code>paginate()</code> in JavaScript? First, get the index of
the <code>current</code> page in the array of <code>pages</code>. If <code>current</code> is found, then
get its neighbors and return an array of <code>[previous, next]</code>; otherwise,
return nothing.</p>

<p>Implementing <code>html()</code> is pretty straightforward: get that array and render
it to a string.</p>

<h2 id="Na&amp;#x00EF;ve%20implementation%20in%20ECMAScript%205.">Na&#x00EF;ve implementation in ECMAScript 5.</h2>

<pre><code>var pages = [&#39;index&#39;, &#39;vanilla&#39;, &#39;ramda&#39;, &#39;elm&#39;];
var current = &#39;vanilla&#39;;

var paginate = function(current, pages) {

  // Get index of current page
  // in array of pages
  var i = pages.indexOf(current);

  // If current page is found
  // (index is not -1)
  return i !== -1
    ? ([ pages[i - 1], // Previous page
        pages[i + 1]  // Next page
      ])
    // else return undefined
    : undefined;
}

var html = function(pagination) {
  if (pagination === undefined) return &#39;Current not found&#39;;

  var previous =
    pagination[0] === undefined
      ? &#39;No previous&#39;
      : (&#39;&lt;a href=&quot;&#39; + pagination[0] + &#39;&quot;&gt;Previous&lt;/a&gt;&#39;);

  var next =
    pagination[1] === undefined
      ? &#39;No next&#39;
      : (&#39;&lt;a href=&quot;&#39; + pagination[1] + &#39;&quot;&gt;Next&lt;/a&gt;&#39;);

  return (previous + next);
}
</code></pre>

<p>Now we can test our functions.</p>

<pre><code>pages = [&#39;index&#39;, &#39;vanilla&#39;, &#39;ramda&#39;, &#39;elm&#39;]
// =&gt; &#39;[&quot;index&quot;, &quot;vanilla&quot;, &quot;ramda&quot;, &quot;elm&quot;]&#39;

current = &#39;vanilla&#39;
// =&gt; &quot;vanilla&quot;

paginate(current, pages)
// =&gt; [&quot;index&quot;, &quot;ramda&quot;]

html(paginate(current, pages))
// =&gt; &quot;&lt;a href=\&quot;index\&quot;&gt;Previous&lt;/a&gt;&lt;a href=\&quot;ramda\&quot;&gt;Next&lt;/a&gt;&quot;
</code></pre>

<h2 id="How%20can%20we%20improve%20it?">How can we improve it?</h2>

<p>First, those <code>undefined</code> values look suspicious. Just take a look at the
edge case, when <strong>previous</strong> is <code>undefined</code>:</p>

<pre><code>paginate(&#39;index&#39;, pages)
// =&gt; [undefined, &quot;vanilla&quot;]
</code></pre>

<p>We need some safer data types.</p>

<p>Second, those <code>if</code> and <code>else</code> statements are a problem. It is possible to
forget something and accidentally miss a case.</p>

<p>We need a better way to branch our code.</p>

<h2 id="Built%20with%20Ramda">Built with Ramda</h2>

<p>Before we dive in into our implementation, let&#8217;s get familiar with Ramda,
a functional library for JavaScript.</p>

<p>If you haven&#8217;t tried functional programming before, it may look unusual,
but it&#8217;s totally worth learning. It is consistently simple, backed by
math, and fun to learn.</p>

<h2 id="Ramda">Ramda</h2>

<p>Ramda helps us to write code in a purer functional style. It&#8217;s a small
library, has no dependencies, and works in all browsers as well as Node.</p>

<pre><code>var numbers = [10, 20, 30, 40];
var inc = function (x) { return (x + 1); }
</code></pre>

<p>Compare the native <code>map</code>&#8230;</p>

<pre><code>numbers.map(inc)
// =&gt; [11, 21, 31, 41]
</code></pre>

<p>&#8230; with Ramda&#8217;s:</p>

<pre><code>R.map(inc, numbers)
// =&gt; [11, 21, 31, 41]
</code></pre>

<p>It doesn&#8217;t look that different at the beginning&#8230; but it&#8217;s only the
beginning.</p>

<p>How does <code>map()</code> work? It takes a function and a functor (e.g., array,
string, or object), applies the function to each of the functor&#8217;s values,
and returns a functor of the same shape.</p>

<pre><code>R.map(inc, {a: 100, b: 200})
// =&gt; {&quot;a&quot;: 101, &quot;b&quot;: 201}

R.map(inc, {a: &#39;a&#39;, b: &#39;b&#39;})
// =&gt; {&quot;a&quot;: &quot;a1&quot;, &quot;b&quot;: &quot;b1&quot;}

R.map(inc, &#39;abc&#39;)
// =&gt; [&quot;a1&quot;, &quot;b1&quot;, &quot;c1&quot;]
</code></pre>

<p>What happens when you pass fewer parameters than the function expects?
Usually JavaScript functions are not happy:</p>

<pre><code>numbers.map()
// =&gt; TypeError: Array.prototype.map callback must be a function
</code></pre>

<p>Now look at the Ramda function:</p>

<pre><code>R.map()
// =&gt; function n(r,e){switch(arguments.length){case 0:return n;case 1:return b(r)?n:L(function(n){return t(r,n)});default:return b(r)&amp;&amp;b(e)?n:b(r)?L(function(n){return t(n,e)}):b(e)?L(function(n){return t(r,n)}):t(r,e)}}
</code></pre>

<p>That&#8217;s right &#8212; it returns a function. If there were no parameters
passed, it returns itself. Just double checking:</p>

<pre><code>R.map
// =&gt; function n(r,e){switch(arguments.length){case 0:return n;case 1:return b(r)?n:L(function(n){return t(r,n)});default:return b(r)&amp;&amp;b(e)?n:b(r)?L(function(n){return t(n,e)}):b(e)?L(function(n){return t(r,n)}):t(r,e)}}
</code></pre>

<p>What if you pass one parameter instead of two?</p>

<pre><code>incAll = R.map(inc)
// =&gt; function n(r){return 0===arguments.length||b(r)?n:t.apply(this,arguments)}
</code></pre>

<p>It returns a partially applied function.</p>

<p>All Ramda functions are automatically curried and work this way. A
<em>curried</em> function can take only a subset of its parameters and return a
new function that takes the remaining parameters. If you call a curried
function with all of its parameters, it just calls the function and
returns a value.</p>

<p>So all of the following expressions return the same result:</p>

<pre><code>incAll(numbers)
// =&gt; [11, 21, 31, 41]

R.map(inc, numbers)
// =&gt; [11, 21, 31, 41]

R.map(inc)(numbers)
// =&gt; [11, 21, 31, 41]

R.map()(inc)(numbers)
// =&gt; [11, 21, 31, 41]
</code></pre>

<p>Note that in most Ramda functions the data is supplied as the last
parameter, to make it convenient for currying.</p>

<p>By the way, Ramda has <code>R.inc()</code> and <code>R.dec()</code> already.</p>

<pre><code>R.map(R.dec)(numbers)
// =&gt; [9, 19, 29, 39]
</code></pre>

<p>Probably the simplest Ramda function is <code>R.identity()</code>. It does nothing
but return the parameter supplied to it, so it&#8217;s good as a placeholder
function. We will use it in the example.</p>

<pre><code>R.map(R.identity)(numbers)
// =&gt; [10, 20, 30, 40]
</code></pre>

<p>The next two function names speak for themselves: <code>R.head()</code> returns the
first element of the array.</p>

<pre><code>R.head(numbers)
// =&gt; 10
</code></pre>

<p><code>R.last()</code> returns the last element of the array.</p>

<pre><code>R.last(numbers)
// =&gt; 40
</code></pre>

<p>The last function you need to learn for now is <code>R.concat()</code>.</p>

<pre><code>R.concat(numbers, 50)
// =&gt; [10, 20, 30, 40, 50]
</code></pre>

<p>I am glad you got this far! Finally, we are at the point where we can get
rid of <code>undefined</code>. There is a library for this. :)</p>

<h2 id="Sanctuary">Sanctuary</h2>

<p>Sanctuary is a functional programming library. It depends on and works
nicely with Ramda.</p>

<p>Let&#8217;s compare what two <code>indexOf</code> functions return when the element is not
found in the array:</p>

<pre><code>R.indexOf(42, numbers)
// =&gt; -1
</code></pre>

<p><code>-1</code>? Okay. Kind of weird, but familiar. Now look at Sanctuary&#8217;s version:</p>

<pre><code>S.indexOf(42, numbers)
// =&gt; Nothing()
</code></pre>

<p>It returns a value of <code>Maybe</code> type. <code>Maybe</code> is useful for composing
functions that might not return a value.</p>

<p>Here&#8217;s one more example of a function which returns <code>Maybe</code>.</p>

<p><code>S.at()</code> takes an index and a list and returns <code>Just</code> the element of the
list at the index, if the index is within the list&#8217;s bounds&#8230;</p>

<pre><code>S.at(1, numbers)
// =&gt; Just(20)
</code></pre>

<p>&#8230; and returns <code>Nothing</code> otherwise.</p>

<pre><code>S.at(100, numbers)
// =&gt; Nothing()
</code></pre>

<p>Compare it with the native JavaScript alternative:</p>

<pre><code>numbers[100]
// =&gt; undefined
</code></pre>

<p>Okay, sounds like we can get rid of <code>undefined</code>. But how should we handle
<code>Maybe</code> values? To apply functions to <code>Maybe</code> values you can use old good
<code>map</code>:</p>

<pre><code>R.map(R.inc, S.Just(3))
// =&gt; Just(4)

R.map(R.inc, S.Nothing())
// =&gt; Nothing()
</code></pre>

<p>But what about branching code without using conditionals? In our case, we
have two branches, left and right.</p>

<pre><code>pagination[2] === undefined
  ? &#39;No next&#39;                                     // Left
  : (&#39;&lt;a href=&quot;&#39; + pagination[2] + &#39;&quot;&gt;Next&lt;/a&gt;&#39;); // Right
</code></pre>

<p>To handle it, we can convert <code>Maybe</code> to <code>Either</code>. What is <code>Either</code>? The
<code>Either</code> type represents values with two possibilities, <code>Left</code> and
<code>Right</code>.</p>

<pre><code>S.maybeToEither(&#39;No next&#39;, S.Just(3))
// =&gt; Right(3)

S.maybeToEither(&#39;No next&#39;, S.Nothing())
// =&gt; Left(&quot;No next&quot;)
</code></pre>

<p>Now we can apply two different functions to <code>Left</code> and <code>Right</code>.</p>

<p>When the third parameter is <code>Left</code>, then <code>R.identity()</code> is applied to <code>&#39;No
next&#39;</code>. Let&#8217;s hard-code the third parameter to test <code>S.either</code>.</p>

<pre><code>S.either(R.identity, R.toString, S.Left(&#39;No next&#39;))
// =&gt; &quot;No next&quot;
</code></pre>

<p>When the third parameter is <code>Right</code>, then <code>R.toString()</code> is applied to
<code>3</code>. The third parameter is hard-coded again.</p>

<pre><code>S.either(R.identity, R.toString, S.Right(3))
// =&gt; &quot;3&quot;
</code></pre>

<p>Congratulations! Now you are ready to read the refactored solution. ;)</p>

<h2 id="Implementation%20with%20Ramda%20and%20Sanctuary">Implementation with Ramda and Sanctuary</h2>

<pre><code>// var R = require(&#39;ramda&#39;);
// var S = require(&#39;sanctuary&#39;);

var pages = [&#39;index&#39;, &#39;vanilla&#39;, &#39;ramda&#39;, &#39;elm&#39;];
var current = &#39;ramda&#39;;

var paginate = function(current, pages) {

  return R.map(
    function(index) {
      return [
        S.at(R.dec(index), pages),
        S.at(R.inc(index), pages)
      ]
    },
    // Gets index of the current page
    S.indexOf(current, pages)
  )
}

var html = function(pagination) {

  var previous =
    function(url) {
      return (&#39;&lt;a href=&quot;&#39; + url + &#39;&quot;&gt;Previous&lt;/a&gt;&#39;);
    }

  var next =
    function(url) {
      return (&#39;&lt;a href=&quot;&#39; + url + &#39;&quot;&gt;Next&lt;/a&gt;&#39;);
    }

  var buttons = function(x) {
    return R.concat(
      S.either(
        R.identity,
        previous,
        S.maybeToEither(&#39;No previous&#39;, R.head(x))
      ),
      S.either(
        R.identity,
        next,
        S.maybeToEither(&#39;No next&#39;, R.last(x))
      )
    )
  }

  return S.either(
    R.identity,
    buttons,
    S.maybeToEither(&#39;Current not found&#39;, pagination)
  )
}
</code></pre>

<p>Let&#8217;s test it.</p>

<pre><code>pages = [&#39;index&#39;, &#39;vanilla&#39;, &#39;ramda&#39;, &#39;elm&#39;]
// =&gt; [&quot;index&quot;, &quot;vanilla&quot;, &quot;ramda&quot;, &quot;elm&quot;]

current = &#39;ramda&#39;
// =&gt; &quot;ramda&quot;

paginate(&#39;ramda&#39;, pages)
// =&gt; Just([Just(&quot;vanilla&quot;), Just(&quot;elm&quot;)])

html(paginate(&#39;ramda&#39;, pages))
// =&gt; &quot;&lt;a href=\&quot;vanilla\&quot;&gt;Previous&lt;/a&gt;&lt;a href=\&quot;elm\&quot;&gt;Next&lt;/a&gt;&quot;
</code></pre>

<h2 id="What%20can%20we%20improve?">What can we improve?</h2>

<p>Syntax. It is getting pretty lengthy and noisy. ECMAScript 2015 solves
this partially.</p>

<pre><code>const paginate = (current, pages) =&gt; R.map(
  (i) =&gt; R.map(
    S.at(R.dec(i), pages),
    S.at(R.inc(i), pages)
  ), S.indexOf(current, pages)
)
</code></pre>

<p>By the way, here&#8217;s our vanilla version in ECMAScript 2015.</p>

<pre><code>const paginate = (current, pages) =&gt; {
  const i = pages.indexOf(current);
  return i !== -1
    ? [pages[i - 1], pages[i + 1]]
    : undefined;
}
</code></pre>

<p>Another problem with our solution is that <code>html()</code> returns a string. It
would be good to have DOM elements instead. To manipulate the DOM we can
use one of the Virtual DOM libraries or frameworks, like React, Angular,
Ember, or Vue.</p>

<p>If we&#8217;re looking for a lighter and purely functional solution, Elm is
a better option.</p>

<h2 id="Built%20with%20Elm">Built with Elm</h2>

<p>I have been playing with Elm for several months and find it fascinating:
Helpful error messages. If it compiles, it works; no runtime errors; good
performance; clean syntax; simple refactoring, and so on.</p>

<h2 id="Writing%20in%20Elm">Writing in Elm</h2>

<p>Create a file, say <code>pagination.elm</code>. If you are using any modules, you
have to import them explicitly.</p>

<p>For this implementation in Elm I&#8217;m using the <code>List</code> type for the list of
pages. To get value by index, we use <code>getAt()</code> and to get index by value,
we use <code>elemIndex()</code>. Both functions are from the <code>List.Extra</code> module;
let&#8217;s import it.</p>

<pre><code>import List.Extra

List.Extra.getAt 3 pages
-- Just &quot;elm&quot;
</code></pre>

<p>We can use the <code>exposing</code> keyword to import particular functions of the
module, and then call them <em>without a qualifier</em>.</p>

<pre><code>import List.Extra exposing (getAt, elemIndex)

getAt 3 pages
-- Just &quot;elm&quot;

elemIndex &quot;elm&quot; pages
-- Just 3
</code></pre>

<p>As you can see, you don&#8217;t need brackets in these function calls, just the
function name and a list of its parameters.</p>

<p>To define a function you just type in a function name, then a list of its
parameters, then the <code>=</code> sign, and finally its definition.</p>

<pre><code>inc x = x + 1

inc 1
-- 2
</code></pre>

<p>You can define local functions inside a function with the <code>let ... in</code>
keywords.</p>

<pre><code>current = &quot;ramda&quot;

isCurrent page =
    let
        current = &quot;elm&quot;
    in
        page == current

isCurrent &quot;elm&quot;
-- True
</code></pre>

<p>To handle cases you can use the <code>case ... of</code> keywords, which is useful
for pattern matching. The important difference with Elm is that its
compiler won&#8217;t let you forget to cover cases, and will make sure all
branches return values of the same shape.</p>

<pre><code>get index pages =
    case index of
        Just i -&gt;
            &quot;Index is &quot; ++ i

        Nothing -&gt;
            &quot;No index&quot;
</code></pre>

<p>You&#8217;ve probably noticed that for summing numbers in Elm we use <code>+</code>, but to
concatenate strings we need <code>++</code>.</p>

<p>Our function <code>paginate()</code> returns a tuple, which is a data type in Elm.
Here&#8217;s the syntax.</p>

<pre><code>pagination = (Just &quot;elm&quot;, Nothing)
</code></pre>

<p>Oh, the <code>Maybe</code> type is in the Elm core library, so you don&#8217;t need to
import it.</p>

<p>HTML elements are functions of the <code>Html</code> module. To create a link &#8212;
HTML element <code>&lt;A&gt;</code> &#8212; you need to call the function <code>Html.a</code> with two
parameters: list of attributes and list of children.</p>

<pre><code>Html.a [ Html.Attributes.href &quot;ramda&quot; ] [ Html.text &quot;Previous&quot; ]
</code></pre>

<p>As you can guess, <code>href</code> is a function from the <code>Html.Attributes</code> module,
and <code>text</code> is a function from the <code>Html</code> module.</p>

<p>That&#8217;s it. You know enough Elm to read the code:</p>

<pre><code>import Html exposing (div, text, a)
import Html.Attributes exposing (href)
import List.Extra exposing (getAt, elemIndex)


pages =
    [ &quot;index&quot;, &quot;vanilla&quot;, &quot;ramda&quot;, &quot;elm&quot; ]


current =
    &quot;elm&quot;


paginate current pages =
    case (elemIndex current pages) of
        Just i -&gt;
            ( (getAt (i - 1) pages), (getAt (i + 1) pages) )

        _ -&gt;
            ( Nothing, Nothing )


html pagination =
    let
        next page =
            case page of
                Just url -&gt;
                    a [ href url ] [ text &quot;Next&quot; ]

                Nothing -&gt;
                    text &quot;No next&quot;

        previous page =
            case page of
                Just url -&gt;
                    a [ href url ] [ text &quot;Previous&quot; ]

                Nothing -&gt;
                    text &quot;No previous&quot;
    in
        case pagination of
            ( Nothing, Nothing ) -&gt;
                text &quot;Current not found&quot;

            ( p, n ) -&gt;
                div [] [ previous p, next n ]


main =
    html (paginate current pages)
</code></pre>

<h2 id="Epilogue">Epilogue</h2>

<p>You may ask, what&#8217;s the point of adding lines of code and introducing new
libraries and weird data types &#8212; even a new language! Doesn&#8217;t it
complicate everything?</p>

<p>First, type safety helps you to avoid runtime errors and catch mistakes
earlier. Second, pure functions are much simpler to understand, to
maintain, and to refactor. Third, in most cases composability and
point-free style make your code much cleaner.</p>

<p>If you&#8217;re building a small web app and file size is critical, then nothing
can beat vanilla JavaScript, of course. However, when your app grows,
Ramda or Elm can save you from mistakes and make your developer experience
much better.</p>

<p>You&#8217;d still better know <a href="http://dorey.github.io/JavaScript-Equality-Table/">JavaScript equality
quirks</a>, how to
manipulate the
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model">DOM</a>
directly, how to manage scope, how to avoid mutable state, how to handle
<code>null</code>, etc.</p>

<p>If JavaScript is so weird, why should we learn it? Because 3 billion
people use web browsers and  JavaScript is the only scripting language
natively supported by most web browsers today. JavaScript is getting
better, but it won&#8217;t be changed dramatically anytime soon.</p>

<h2 id="Bonus%20track">Bonus track</h2>

<p>Thank you for reading this far! Here&#8217;s another implementation with the Elm
core library only. You can copy-paste it to <a href="http://elm-lang.org/try">Elm
REPL</a> and play with it.</p>

<pre><code>import Html
import List

pages = [ &quot;index&quot;, &quot;vanilla&quot;, &quot;ramda&quot;, &quot;elm&quot; ]
current = &quot;elm&quot;

paginate current pages =
    let
        cs = pages |&gt; List.map Just
        ns = List.drop 1 cs ++ [ Nothing ]
        ps = Nothing :: List.take (List.length cs - 1) cs
        isCurrent (p, c, n) =
            case c == Just current of
                True -&gt; Just (p, n)
                False -&gt; Nothing
    in
        List.map3 (\p c n -&gt; ( p, c, n )) ps cs ns
          |&gt; List.filterMap isCurrent

main =
    paginate current pages
      |&gt; toString
      |&gt; Html.text
      -- Just (Just &quot;ramda&quot;, Just &quot;elm&quot;, Nothing)
</code></pre>

<h2 id="See%20also">See also</h2>

<p><a href="https://guide.elm-lang.org">An Introduction to Elm by Evan Czaplicki</a>,
<a href="https://github.com/ramda/ramda/wiki/Type-Signatures">Type Signatures by Scott Sauyet</a>,
<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures by Aditya Bhargava</a>,
<a href="http://randycoulman.com/blog/categories/thinking-in-ramda/">Thinking in Ramda by Randy Coulman</a>,
<a href="https://github.com/MostlyAdequate/mostly-adequate-guide">Professor Frisby&#8217;s Mostly Adequate Guide to FP by Brian Lonsdorf</a>,
<a href="https://github.com/getify/functional-light-js">Functional-Light JavaScript by Kyle Simpson</a>,
<a href="https://github.com/stoeffel/awesome-fp-js">Awesome FP JavaScript</a></p></div>
<div class="footer">&copy; <a href="/">Roman Zolotarev</a></div>
</div></body></html>
